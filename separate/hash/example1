bean: aa
algebra: 45623
thingsandstuff:%%%%
coolandnice:23232
Entity: system -
works: relatively well,
reasonable: frame rate
at: 10000 cubes
with: multiple aspects
and: behaviours +
100: new flying
spheres: a second.
OpenGL: facilities wrappers
handles: uploading to
vram:, etc.,
managing: vertex formats)
A: "Renderer" encapsulates
shader: programs and
the: uniforms that
need: to be
updated: when you
draw: a mesh
with: this renderer.
A: renderer can
draw: meshes that
have: a superset
of: the vertex
format: bits specified
by: the renderer
that: probably are
needed: by its
shaders:).
loading:
format: querying, I
underestimated: this. Could
just: use a
library: but I
/* Hello this is a /* comment
choo/*i recur inside to myself*/ choo*/!!! */
want: to learn
how: to write
things:
Facilities: for using
PLY: file as
generic: database file
and: querying data
to: be packed
into: a given
format: in application
memory:.
think: this will
// be: very useful,
and: could be
// the: format I thing /* and stuff and wow
use: for numerical */
cluster:"/collections data.

thing23289: #line 2 "hash.c"
thing23290:
thing23291:#line 4 "hash.c"
thing23292:
thing23293:#define  YY_INT_ALIGNED short int
thing23294:
thing23295:/* A lexical scanner generated by flex */
thing23296:
thing23297:#define FLEX_SCANNER
thing23298:#define YY_FLEX_MAJOR_VERSION 2
thing23299:#define YY_FLEX_MINOR_VERSION 6
thing23300:#define YY_FLEX_SUBMINOR_VERSION 4
thing23301:#if YY_FLEX_SUBMINOR_VERSION > 0
thing23302:#define FLEX_BETA
thing23303:#endif
thing23304:
thing23305:/* First, we deal with  platform-specific or compiler-specific issues. */
thing23306:
thing23307:/* begin standard C headers. */
thing23308:#include <stdio.h>
thing23309:#include <string.h>
thing23310:#include <errno.h>
thing23311:#include <stdlib.h>
thing23312:
thing23313:/* end standard C headers. */
thing23314:
thing23315:/* flex integer type definitions */
thing23316:
thing23317:#ifndef FLEXINT_H
thing23318:#define FLEXINT_H
thing23319:
thing23320:/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
thing23321:
thing23322:#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
thing23323:
thing23324:/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
thing23325: if you want the limit (max/min) macros for int types. 
thing23326:/
thing23327:#ifndef __STDC_LIMIT_MACROS
thing23328:#define __STDC_LIMIT_MACROS 1
thing23329:#endif
thing23330:
thing23331:#include <inttypes.h>
thing23332:typedef int8_t flex_int8_t;
thing23333:typedef uint8_t flex_uint8_t;
thing23334:typedef int16_t flex_int16_t;
thing23335:typedef uint16_t flex_uint16_t;
thing23336:typedef int32_t flex_int32_t;
thing23337:typedef uint32_t flex_uint32_t;
thing23338:#else
thing23339:typedef signed char flex_int8_t;
thing23340:typedef short int flex_int16_t;
thing23341:typedef int flex_int32_t;
thing23342:typedef unsigned char flex_uint8_t; 
thing23343:typedef unsigned short int flex_uint16_t;
thing23344:typedef unsigned int flex_uint32_t;
thing23345:
thing23346:/* Limits of integral types. */
thing23347:#ifndef INT8_MIN
thing23348:#define INT8_MIN               (-128)
thing23349:#endif
thing23350:#ifndef INT16_MIN
thing23351:#define INT16_MIN              (-32767-1)
thing23352:#endif
thing23353:#ifndef INT32_MIN
thing23354:#define INT32_MIN              (-2147483647-1)
thing23355:#endif
thing23356:#ifndef INT8_MAX
thing23357:#define INT8_MAX               (127)
thing23358:#endif
thing23359:#ifndef INT16_MAX
thing23360:#define INT16_MAX              (32767)
thing23361:#endif
thing23362:#ifndef INT32_MAX
thing23363:#define INT32_MAX              (2147483647)
thing23364:#endif
thing23365:#ifndef UINT8_MAX
thing23366:#define UINT8_MAX              (255U)
thing23367:#endif
thing23368:#ifndef UINT16_MAX
thing23369:#define UINT16_MAX             (65535U)
thing23370:#endif
thing23371:#ifndef UINT32_MAX
thing23372:#define UINT32_MAX             (4294967295U)
thing23373:#endif
thing23374:
thing23375:#ifndef SIZE_MAX
thing23376:#define SIZE_MAX               (~(size_t)0)
thing23377:#endif
thing23378:
thing23379:#endif /* ! C99 */
thing23380:
thing23381:#endif /* ! FLEXINT_H */
thing23382:
thing23383:/* begin standard C++ headers. */
thing23384:
thing23385:/* TODO: this is always defined, so inline it */
thing23386:#define yyconst const
thing23387:
thing23388:#if defined(__GNUC__) && __GNUC__ >= 3
thing23389:#define yynoreturn __attribute__((__noreturn__))
thing23390:#else
thing23391:#define yynoreturn
thing23392:#endif
thing23393:
thing23394:/* Returned upon end-of-file. */
thing23395:#define YY_NULL 0
thing23396:
thing23397:/* Promotes a possibly negative, possibly signed char to an
thing23398:   integer in range [0..255] for use as an array index.
thing23399:/
thing23400:#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
thing23401:
thing23402:/* Enter a start condition.  This macro really ought to take a parameter,
thing23403: but we do it the disgusting crufty way forced on us by the ()-less
thing23404: definition of BEGIN.
thing23405:/
thing23406:#define BEGIN (yy_start) = 1 + 2 *
thing23407:/* Translate the current start state into a value that can be later handed
thing23408: to BEGIN to return to the state.  The YYSTATE alias is for lex
thing23409: compatibility.
thing23410:/
thing23411:#define YY_START (((yy_start) - 1) / 2)
thing23412:#define YYSTATE YY_START
thing23413:/* Action number for EOF rule of a given start state. */
thing23414:#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
thing23415:/* Special action meaning "start processing a new file". */
thing23416:#define YY_NEW_FILE yyrestart( yyin  )
thing23417:#define YY_END_OF_BUFFER_CHAR 0
thing23418:
thing23419:/* Size of default input buffer. */
thing23420:#ifndef YY_BUF_SIZE
thing23421:#ifdef __ia64__
thing23422:/* On IA-64, the buffer size is 16k, not 8k.
thing23423: Moreover, YY_BUF_SIZE is 2:YY_READ_BUF_SIZE in the general case.
thing23424: Ditto for the __ia64__ case accordingly.
thing23425:/
thing23426:#define YY_BUF_SIZE 32768
thing23427:#else
thing23428:#define YY_BUF_SIZE 16384
thing23429:#endif /* __ia64__ */
thing23430:#endif
thing23431:
thing23432:/* The state buf must be large enough to hold one state per character in the main buffer.
thing23433:/
thing23434:#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
thing23435:
thing23436:#ifndef YY_TYPEDEF_YY_BUFFER_STATE
thing23437:#define YY_TYPEDEF_YY_BUFFER_STATE
thing23438:typedef struct yy_buffer_state *YY_BUFFER_STATE;
thing23439:#endif
thing23440:
thing23441:#ifndef YY_TYPEDEF_YY_SIZE_T
thing23442:#define YY_TYPEDEF_YY_SIZE_T
thing23443:typedef size_t yy_size_t;
thing23444:#endif
thing23445:
thing23446:extern int yyleng;
thing23447:
thing23448:extern FILE *yyin, *yyout;
thing23449:
thing23450:#define EOB_ACT_CONTINUE_SCAN 0
thing23451:#define EOB_ACT_END_OF_FILE 1
thing23452:#define EOB_ACT_LAST_MATCH 2
thing23453:
thing23454:#define YY_LESS_LINENO(n)
thing23455:#define YY_LINENO_REWIND_TO(ptr)
thing23456:
thing23457:/* Return all but the first "n" matched characters back to the input stream. */
thing23458:#define yyless(n) \
thing23459:do \
thing23460:{ \
thing23461:/* Undo effects of setting up yytext. */ \
thing23462:int yyless_macro_arg = (n); \
thing23463:YY_LESS_LINENO(yyless_macro_arg);\
thing23464:*yy_cp = (yy_hold_char); \
thing23465:YY_RESTORE_YY_MORE_OFFSET \
thing23466:(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
thing23467:YY_DO_BEFORE_ACTION; /* set up yytext again */ \
thing23468:} \
thing23469:while ( 0 )
thing23470:#define unput(c) yyunput( c, (yytext_ptr)  )
thing23471:
thing23472:#ifndef YY_STRUCT_YY_BUFFER_STATE
thing23473:#define YY_STRUCT_YY_BUFFER_STATE
thing23474:struct yy_buffer_state
thing23475:{
thing23476:FILE *yy_input_file;
thing23477:
thing23478:char *yy_ch_buf;		/* input buffer */
thing23479:char *yy_buf_pos;		/* current position in input buffer */
thing23480:
thing23481:/* Size of input buffer in bytes, not including room for EOB
thing23482: characters.
thing23483:/
thing23484:int yy_buf_size;
thing23485:
thing23486:/* Number of characters read into yy_ch_buf, not including EOB
thing23487: characters.
thing23488:/
thing23489:int yy_n_chars;
thing23490:
thing23491:/* Whether we "own" the buffer - i.e., we know we created it,
thing23492: and can realloc() it to grow it, and should free() it to
thing23493: delete it.
thing23494:/
thing23495:int yy_is_our_buffer;
thing23496:
thing23497:/* Whether this is an "interactive" input source; if so, and
thing23498: if we're using stdio for input, then we want to use getc()
thing23499: instead of fread(), to make sure we stop fetching input after
thing23500: each newline.
thing23501:/
thing23502:int yy_is_interactive;
thing23503:
thing23504:/* Whether we're considered to be at the beginning of a line.
thing23505: If so, '^' rules will be active on the next match, otherwise
thing23506: not.
thing23507:/
thing23508:int yy_at_bol;
thing23509:
thing23510:int yy_bs_lineno; /**< The line count. */
thing23511:int yy_bs_column; /**< The column count. */
thing23512:
thing23513:/* Whether to try to fill the input buffer when we reach the
thing23514: end of it.
thing23515:/
thing23516:int yy_fill_buffer;
thing23517:
thing23518:int yy_buffer_status;
thing23519:
thing23520:#define YY_BUFFER_NEW 0
thing23521:#define YY_BUFFER_NORMAL 1
thing23522:/* When an EOF's been seen but there's still some text to process
thing23523: then we mark the buffer as YY_EOF_PENDING, to indicate that we
thing23524: shouldn't try reading from the input source any more.  We might
thing23525: still have a bunch of tokens to match, though, because of
thing23526: possible backing-up.
thing23527:
thing23528: When we actually see the EOF, we change the status to "new"
thing23529: (via yyrestart()), so that the user can continue scanning by
thing23530: just pointing yyin at a new input file.
thing23531:/
thing23532:#define YY_BUFFER_EOF_PENDING 2
thing23533:
thing23534:};
thing23535:#endif /* !YY_STRUCT_YY_BUFFER_STATE */
thing23536:
thing23537:/* Stack of input buffers. */
thing23538:static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
thing23539:static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
thing23540:static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
thing23541:
thing23542:/* We provide macros for accessing buffer states in case in the
thing23543: future we want to put the buffer states in a more general
thing23544: "scanner state".
thing23545:
thing23546: Returns the top of the stack, or NULL.
thing23547:/
thing23548:#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
thing23549: (yy_buffer_stack)[(yy_buffer_stack_top)] \
thing23550: NULL)
thing23551:/* Same as previous macro, but useful when we know that the buffer stack is not
thing23552: NULL or when we need an lvalue. For internal use only.
thing23553:/
thing23554:#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
thing23555:
thing23556:/* yy_hold_char holds the character lost when yytext is formed. */
thing23557:static char yy_hold_char;
thing23558:static int yy_n_chars;		/* number of characters read into yy_ch_buf */
thing23559:int yyleng;
thing23560:
thing23561:/* Points to current character in buffer. */
thing23562:static char *yy_c_buf_p = NULL;
thing23563:static int yy_init = 0;		/* whether we need to initialize */
thing23564:static int yy_start = 0;	/* start state number */
thing23565:
thing23566:/* Flag which is used to allow yywrap()'s to do buffer switches
thing23567: instead of setting up a fresh yyin.  A bit of a hack ...
thing23568:/
thing23569:static int yy_did_buffer_switch_on_eof;
thing23570:
thing23571:void yyrestart ( FILE *input_file  );
thing23572:void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
thing23573:YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
thing23574:void yy_delete_buffer ( YY_BUFFER_STATE b  );
thing23575:void yy_flush_buffer ( YY_BUFFER_STATE b  );
thing23576:void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
thing23577:void yypop_buffer_state ( void );
thing23578:
thing23579:static void yyensure_buffer_stack ( void );
thing23580:static void yy_load_buffer_state ( void );
thing23581:static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
thing23582:#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
thing23583:
thing23584:YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
thing23585:YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
thing23586:YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
thing23587:
thing23588:void *yyalloc ( yy_size_t  );
thing23589:void *yyrealloc ( void *, yy_size_t  );
thing23590:void yyfree ( void *  );
thing23591:
thing23592:#define yy_new_buffer yy_create_buffer
thing23593:#define yy_set_interactive(is_interactive) \
thing23594:{ \
thing23595:if ( ! YY_CURRENT_BUFFER ){ \
thing23596:yyensure_buffer_stack (); \
thing23597:YY_CURRENT_BUFFER_LVALUE =    \
thing23598:yy_create_buffer( yyin, YY_BUF_SIZE ); \
thing23599:} \
thing23600:YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
thing23601:}
thing23602:#define yy_set_bol(at_bol) \
thing23603:{ \
thing23604:if ( ! YY_CURRENT_BUFFER ){\
thing23605:yyensure_buffer_stack (); \
thing23606:YY_CURRENT_BUFFER_LVALUE =    \
thing23607:yy_create_buffer( yyin, YY_BUF_SIZE ); \
thing23608:} \
thing23609:YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
thing23610:}
thing23611:#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
thing23612:
thing23613:/* Begin user sect3 */
thing23614:
thing23615:#define yywrap() (/*CONSTCOND*/1)
thing23616:#define YY_SKIP_YYWRAP
thing23617:typedef flex_uint8_t YY_CHAR;
thing23618:
thing23619:FILE *yyin = NULL, *yyout = NULL;
thing23620:
thing23621:typedef int yy_state_type;
thing23622:
thing23623:extern int yylineno;
thing23624:int yylineno = 1;
thing23625:
thing23626:extern char *yytext;
thing23627:#ifdef yytext_ptr
thing23628:#undef yytext_ptr
thing23629:#endif
thing23630:#define yytext_ptr yytext
thing23631:
thing23632:static yy_state_type yy_get_previous_state ( void );
thing23633:static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
thing23634:static int yy_get_next_buffer ( void );
thing23635:static void yynoreturn yy_fatal_error ( const char* msg  );
thing23636:
thing23637:/* Done after the current pattern has been matched and before the
thing23638: corresponding action - sets up yytext.
thing23639:/
thing23640:#define YY_DO_BEFORE_ACTION \
thing23641:(yytext_ptr) = yy_bp; \
thing23642:yyleng = (int) (yy_cp - yy_bp); \
thing23643:(yy_hold_char) = *yy_cp; \
thing23644:*yy_cp = '\0'; \
thing23645:(yy_c_buf_p) = yy_cp;
thing23646:#define YY_NUM_RULES 13
thing23647:#define YY_END_OF_BUFFER 14
thing23648:/* This struct is not used in this scanner,
thing23649:but its presence is necessary. */
thing23650:struct yy_trans_info
thing23651:{
thing23652:flex_int32_t yy_verify;
thing23653:flex_int32_t yy_nxt;
thing23654:};
thing23655:static const flex_int16_t yy_accept[35] =
thing23656:{   0,
thing23657:0,    0,    0,    0,   11,   11,    0,    0,    0,    0,
thing23658:14,   13,    7,    6,    6,    7,    7,   11,   12,   10,
thing23659:10,   10,    4,    5,    4,    2,    3,    0,    1,   11,
thing23660:9,    8,    1,    0
thing23661:} ;
thing23662:
thing23663:static const YY_CHAR yy_ec[256] =
thing23664:{   0,
thing23665:1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
thing23666:1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
thing23667:1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
thing23668:1,    2,    1,    1,    1,    1,    1,    1,    1,    1,
thing23669:1,    4,    1,    1,    1,    1,    5,    6,    6,    6,
thing23670:6,    6,    6,    6,    6,    6,    6,    7,    1,    1,
thing23671:1,    1,    1,    1,    6,    6,    6,    6,    6,    6,
thing23672:6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
thing23673:6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
thing23674:6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
thing23675:
thing23676:6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
thing23677:6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
thing23678:6,    6,    1,    1,    1,    1,    1,    1,    1,    1,
thing23679:1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
thing23680:1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
thing23681:1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
thing23682:1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
thing23683:1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
thing23684:1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
thing23685:1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
thing23686:
thing23687:1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
thing23688:1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
thing23689:1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
thing23690:1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
thing23691:1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
thing23692:1,    1,    1,    1,    1
thing23693:} ;
thing23694:
thing23695:static const YY_CHAR yy_meta[8] =
thing23696:{   0,
thing23697:1,    2,    3,    1,    1,    1,    1
thing23698:} ;
thing23699:
thing23700:static const flex_int16_t yy_base[40] =
thing23701:{   0,
thing23702:0,    0,    0,    0,   38,   37,    7,    0,   12,   15,
thing23703:39,   42,   42,   42,   42,   17,   17,    0,   42,   42,
thing23704:33,   15,   42,   42,   12,   42,   42,    0,    0,    0,
thing23705:42,   42,    0,   42,   24,   27,   30,   33,   34
thing23706:} ;
thing23707:
thing23708:static const flex_int16_t yy_def[40] =
thing23709:{   0,
thing23710:35,   35,   34,    3,   36,   36,   34,    7,   37,   37,
thing23711:34,   34,   34,   34,   34,   34,   34,   38,   34,   34,
thing23712:34,   34,   34,   34,   34,   34,   34,   17,   39,   38,
thing23713:34,   34,   39,    0,   34,   34,   34,   34,   34
thing23714:} ;
thing23715:
thing23716:static const flex_int16_t yy_nxt[50] =
thing23717:{   0,
thing23718:13,   14,   15,   13,   16,   17,   13,   20,   20,   20,
thing23719:21,   22,   20,   20,   24,   26,   25,   24,   32,   25,
thing23720:26,   27,   28,   29,   12,   12,   12,   18,   18,   18,
thing23721:23,   23,   23,   30,   30,   33,   33,   31,   34,   19,
thing23722:19,   11,   34,   34,   34,   34,   34,   34,   34
thing23723:} ;
thing23724:
thing23725:static const flex_int16_t yy_chk[50] =
thing23726:{   0,
thing23727:3,    3,    3,    3,    3,    3,    3,    7,    7,    7,
thing23728:7,    7,    7,    7,    9,   25,    9,   10,   22,   10,
thing23729:16,   16,   17,   17,   35,   35,   35,   36,   36,   36,
thing23730:37,   37,   37,   38,   38,   39,   39,   21,   11,    6,
thing23731:5,   34,   34,   34,   34,   34,   34,   34,   34
thing23732:} ;
thing23733:
thing23734:static yy_state_type yy_last_accepting_state;
thing23735:static char *yy_last_accepting_cpos;
thing23736:
thing23737:extern int yy_flex_debug;
thing23738:int yy_flex_debug = 0;
thing23739:
thing23740:/* The intent behind this definition is that it'll catch
thing23741: any uses of REJECT which flex missed.
thing23742:/
thing23743:#define REJECT reject_used_but_not_detected
thing23744:#define yymore() yymore_used_but_not_detected
thing23745:#define YY_MORE_ADJ 0
thing23746:#define YY_RESTORE_YY_MORE_OFFSET
thing23747:char *yytext;
thing23748:#line 1 "hash.l"
thing23749:
thing23750:
thing23751:
thing23752:
thing23753:#line 8 "hash.l"
thing23754:#include <stdio.h>
thing23755:#include <stdint.h>
thing23756:#include <ctype.h>
thing23757:
thing23758:#define g_buf_size 1024
thing23759:static char g_key[g_buf_size];
thing23760:
thing23761:typedef struct DictNode_s {
thing23762:void *next;
thing23763:char value;
thing23764:} DictNode;
thing23765:typedef struct Dictionary_s {
thing23766:uint32_t size;
thing23767:void **table;
thing23768:} Dictionary;
thing23769:
thing23770:static void dictionary_add(Dictionary *dictionary, char *key, char *value);
thing23771:static Dictionary *new_dictionary(uint32_t size);
thing23772:static void destroy_dictionary(Dictionary *dictionary);
thing23773:static uint32_t make_hash(char *key);
thing23774:static Dictionary *g_dictionary;
thing23775:
thing23776:int g_comment_depth = 0; // can't do this in C, but be fine with nesting /* */ comments.
thing23777:
thing23778:#line 491 "hash.c"
thing23779:#line 492 "hash.c"
thing23780:
thing23781:#define INITIAL 0
thing23782:#define Key 1
thing23783:#define Value 2
thing23784:#define Comment 3
thing23785:#define CommentOneLine 4
thing23786:
thing23787:#ifndef YY_NO_UNISTD_H
thing23788:/* Special case for "unistd.h", since it is non-ANSI. We include it way
thing23789: down here because we want the user's section 1 to have been scanned first.
thing23790: The user has a chance to override it with an option.
thing23791:/
thing23792:#include <unistd.h>
thing23793:#endif
thing23794:
thing23795:#ifndef YY_EXTRA_TYPE
thing23796:#define YY_EXTRA_TYPE void *
thing23797:#endif
thing23798:
thing23799:static int yy_init_globals ( void );
thing23800:
thing23801:/* Accessor methods to globals.
thing23802:These are made visible to non-reentrant scanners for convenience. */
thing23803:
thing23804:int yylex_destroy ( void );
thing23805:
thing23806:int yyget_debug ( void );
thing23807:
thing23808:void yyset_debug ( int debug_flag  );
thing23809:
thing23810:YY_EXTRA_TYPE yyget_extra ( void );
thing23811:
thing23812:void yyset_extra ( YY_EXTRA_TYPE user_defined  );
thing23813:
thing23814:FILE *yyget_in ( void );
thing23815:
thing23816:void yyset_in  ( FILE * _in_str  );
thing23817:
thing23818:FILE *yyget_out ( void );
thing23819:
thing23820:void yyset_out  ( FILE * _out_str  );
thing23821:
thing23822:int yyget_leng ( void );
thing23823:
thing23824:char *yyget_text ( void );
thing23825:
thing23826:int yyget_lineno ( void );
thing23827:
thing23828:void yyset_lineno ( int _line_number  );
thing23829:
thing23830:/* Macros after this point can all be overridden by user definitions in
thing23831: section 1.
thing23832:/
thing23833:
thing23834:#ifndef YY_SKIP_YYWRAP
thing23835:#ifdef __cplusplus
thing23836:extern "C" int yywrap ( void );
thing23837:#else
thing23838:extern int yywrap ( void );
thing23839:#endif
thing23840:#endif
thing23841:
thing23842:#ifndef YY_NO_UNPUT
thing23843:
thing23844:static void yyunput ( int c, char *buf_ptr  );
thing23845:
thing23846:#endif
thing23847:
thing23848:#ifndef yytext_ptr
thing23849:static void yy_flex_strncpy ( char *, const char *, int );
thing23850:#endif
thing23851:
thing23852:#ifdef YY_NEED_STRLEN
thing23853:static int yy_flex_strlen ( const char * );
thing23854:#endif
thing23855:
thing23856:#ifndef YY_NO_INPUT
thing23857:#ifdef __cplusplus
thing23858:static int yyinput ( void );
thing23859:#else
thing23860:static int input ( void );
thing23861:#endif
thing23862:
thing23863:#endif
thing23864:
thing23865:/* Amount of stuff to slurp up with each read. */
thing23866:#ifndef YY_READ_BUF_SIZE
thing23867:#ifdef __ia64__
thing23868:/* On IA-64, the buffer size is 16k, not 8k */
thing23869:#define YY_READ_BUF_SIZE 16384
thing23870:#else
thing23871:#define YY_READ_BUF_SIZE 8192
thing23872:#endif /* __ia64__ */
thing23873:#endif
thing23874:
thing23875:/* Copy whatever the last rule matched to the standard output. */
thing23876:#ifndef ECHO
thing23877:/* This used to be an fputs(), but since the string might contain NUL's,
thing23878: we now use fwrite().
thing23879:/
thing23880:#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
thing23881:#endif
thing23882:
thing23883:/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
thing23884: is returned in "result".
thing23885:/
thing23886:#ifndef YY_INPUT
thing23887:#define YY_INPUT(buf,result,max_size) \
thing23888:if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
thing23889:{ \
thing23890:int c = '*'; \
thing23891:int n; \
thing23892:for ( n = 0; n < max_size && \
thing23893:c = getc( yyin )) != EOF && c != '\n'; ++n ) \
thing23894:buf[n] = (char) c; \
thing23895:if ( c == '\n' ) \
thing23896:buf[n++] = (char) c; \
thing23897:if ( c == EOF && ferror( yyin ) ) \
thing23898:YY_FATAL_ERROR( "input in flex scanner failed" ); \
thing23899:result = n; \
thing23900:} \
thing23901:else \
thing23902:{ \
thing23903:errno=0; \
thing23904:while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
thing23905:{ \
thing23906:if( errno != EINTR) \
thing23907:{ \
thing23908:YY_FATAL_ERROR( "input in flex scanner failed" ); \
thing23909:break; \
thing23910:} \
thing23911:errno=0; \
thing23912:clearerr(yyin); \
thing23913:} \
thing23914:}\
thing23915:\
thing23916:
thing23917:#endif
thing23918:
thing23919:/* No semi-colon after return; correct usage is to write "yyterminate();" -
thing23920: we don't want an extra ';' after the "return" because that will cause
thing23921: some compilers to complain about unreachable statements.
thing23922:/
thing23923:#ifndef yyterminate
thing23924:#define yyterminate() return YY_NULL
thing23925:#endif
thing23926:
thing23927:/* Number of entries by which start-condition stack grows. */
thing23928:#ifndef YY_START_STACK_INCR
thing23929:#define YY_START_STACK_INCR 25
thing23930:#endif
thing23931:
thing23932:/* Report a fatal error. */
thing23933:#ifndef YY_FATAL_ERROR
thing23934:#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
thing23935:#endif
thing23936:
thing23937:/* end tables serialization structures and prototypes */
thing23938:
thing23939:/* Default declaration of generated scanner - a define so the user can
thing23940: easily add parameters.
thing23941:/
thing23942:#ifndef YY_DECL
thing23943:#define YY_DECL_IS_OURS 1
thing23944:
thing23945:extern int yylex (void);
thing23946:
thing23947:#define YY_DECL int yylex (void)
thing23948:#endif /* !YY_DECL */
thing23949:
thing23950:/* Code executed at the beginning of each rule, after yytext and yyleng
thing23951: have been set up.
thing23952:/
thing23953:#ifndef YY_USER_ACTION
thing23954:#define YY_USER_ACTION
thing23955:#endif
thing23956:
thing23957:/* Code executed at the end of each rule. */
thing23958:#ifndef YY_BREAK
thing23959:#define YY_BREAK /*LINTED*/break;
thing23960:#endif
thing23961:
thing23962:#define YY_RULE_SETUP \
thing23963:YY_USER_ACTION
thing23964:
thing23965:/** The main scanner function which does all the work.
thing23966:/
thing23967:YY_DECL
thing23968:{
thing23969:yy_state_type yy_current_state;
thing23970:char *yy_cp, *yy_bp;
thing23971:int yy_act;
thing23972:
thing23973:if ( !(yy_init) )
thing23974:{
thing23975:(yy_init) = 1;
thing23976:
thing23977:#ifdef YY_USER_INIT
thing23978:YY_USER_INIT;
thing23979:#endif
thing23980:
thing23981:if ( ! (yy_start) )
thing23982:(yy_start) = 1;	/* first start state */
thing23983:
thing23984:if ( ! yyin )
thing23985:yyin = stdin;
thing23986:
thing23987:if ( ! yyout )
thing23988:yyout = stdout;
thing23989:
thing23990:if ( ! YY_CURRENT_BUFFER ) {
thing23991:yyensure_buffer_stack ();
thing23992:YY_CURRENT_BUFFER_LVALUE =
thing23993:yy_create_buffer( yyin, YY_BUF_SIZE );
thing23994:}
thing23995:
thing23996:yy_load_buffer_state(  );
thing23997:}
thing23998:
thing23999:{
thing24000:#line 34 "hash.l"
thing24001:
thing24002:
thing24003:
thing24004:#line 717 "hash.c"
thing24005:
thing24006:while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
thing24007:{
thing24008:yy_cp = (yy_c_buf_p);
thing24009:
thing24010:/* Support of yytext. */
thing24011:*yy_cp = (yy_hold_char);
thing24012:
thing24013:/* yy_bp points to the position in yy_ch_buf of the start of
thing24014: the current run.
thing24015:/
thing24016:yy_bp = yy_cp;
thing24017:
thing24018:yy_current_state = (yy_start);
thing24019:yy_match:
thing24020:do
thing24021:{
thing24022:YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
thing24023:if ( yy_accept[yy_current_state] )
thing24024:{
thing24025:(yy_last_accepting_state) = yy_current_state;
thing24026:(yy_last_accepting_cpos) = yy_cp;
thing24027:}
thing24028:while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
thing24029:{
thing24030:yy_current_state = (int) yy_def[yy_current_state];
thing24031:if ( yy_current_state >= 35 )
thing24032:yy_c = yy_meta[yy_c];
thing24033:}
thing24034:yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
thing24035:++yy_cp;
thing24036:}
thing24037:while ( yy_base[yy_current_state] != 42 );
thing24038:
thing24039:yy_find_action:
thing24040:yy_act = yy_accept[yy_current_state];
thing24041:if ( yy_act == 0 )
thing24042:{ /* have to back up */
thing24043:yy_cp = (yy_last_accepting_cpos);
thing24044:yy_current_state = (yy_last_accepting_state);
thing24045:yy_act = yy_accept[yy_current_state];
thing24046:}
thing24047:
thing24048:YY_DO_BEFORE_ACTION;
thing24049:
thing24050:do_action:	/* This label is used only to access EOF actions. */
thing24051:
thing24052:switch ( yy_act )
thing24053:{ /* beginning of action switch */
thing24054:case 0: /* must back up */
thing24055:/* undo the effects of YY_DO_BEFORE_ACTION */
thing24056:*yy_cp = (yy_hold_char);
thing24057:yy_cp = (yy_last_accepting_cpos);
thing24058:yy_current_state = (yy_last_accepting_state);
thing24059:goto yy_find_action;
thing24060:
thing24061:case 1:
thing24062:/* rule 1 can match eol */
thing24063:YY_RULE_SETUP
thing24064:#line 37 "hash.l"
thing24065:{
thing24066:char *colon = strchr(yytext, ':');
thing24067:if (colon - yytext >= g_buf_size) {
thing24068:fprintf(stderr, "ERROR: Buffer size not large enough to store key.\n");
thing24069:exit(EXIT_FAILURE);
thing24070:}
thing24071:strncpy(g_key, yytext, colon - yytext);
thing24072:g_key[colon - yytext] = '\0';
thing24073:BEGIN Value;
thing24074:}
thing24075:YY_BREAK
thing24076:case 2:
thing24077:YY_RULE_SETUP
thing24078:#line 47 "hash.l"
thing24079:{ printf("GOOOO "); g_comment_depth = 1; BEGIN Comment; }
thing24080:YY_BREAK
thing24081:case 3:
thing24082:YY_RULE_SETUP
thing24083:#line 48 "hash.l"
thing24084:{ printf("magic missile --> "); BEGIN CommentOneLine; }
thing24085:YY_BREAK
thing24086:case 4:
thing24087:YY_RULE_SETUP
thing24088:#line 49 "hash.l"
thing24089:{ printf("ah "); }
thing24090:YY_BREAK
thing24091:case 5:
thing24092:/* rule 5 can match eol */
thing24093:YY_RULE_SETUP
thing24094:#line 50 "hash.l"
thing24095:{ printf(" out of mana\n"); BEGIN Key; }
thing24096:YY_BREAK
thing24097:case 6:
thing24098:/* rule 6 can match eol */
thing24099:YY_RULE_SETUP
thing24100:#line 51 "hash.l"
thing24101:{ /* */ }
thing24102:YY_BREAK
thing24103:case 7:
thing24104:YY_RULE_SETUP
thing24105:#line 52 "hash.l"
thing24106:{
thing24107:fprintf(stderr, "Failed reading key.\n");
thing24108:exit(EXIT_FAILURE);
thing24109:}
thing24110:YY_BREAK
thing24111:case 8:
thing24112:YY_RULE_SETUP
thing24113:#line 56 "hash.l"
thing24114:{ printf("HERE WE GO AGAIN "); g_comment_depth ++; }
thing24115:YY_BREAK
thing24116:case 9:
thing24117:YY_RULE_SETUP
thing24118:#line 57 "hash.l"
thing24119:{ printf(" brrrsshhh\n"); g_comment_depth --; if (g_comment_depth == 0) BEGIN Key; }
thing24120:YY_BREAK
thing24121:case 10:
thing24122:/* rule 10 can match eol */
thing24123:YY_RULE_SETUP
thing24124:#line 58 "hash.l"
thing24125:{ printf("vroom-vroom "); /* */ }
thing24126:YY_BREAK
thing24127:case 11:
thing24128:YY_RULE_SETUP
thing24129:#line 60 "hash.l"
thing24130:{
thing24131:printf("Key: %s, Value: %s\n", g_key, yytext);
thing24132:printf("Hash: %u\n", make_hash(g_key) % g_dictionary->size);
thing24133:
thing24134:dictionary_add(g_dictionary, g_key, yytext);
thing24135:
thing24136:input(); // eat the newline
thing24137:BEGIN Key;
thing24138:}
thing24139:YY_BREAK
thing24140:case 12:
thing24141:/* rule 12 can match eol */
thing24142:YY_RULE_SETUP
thing24143:#line 69 "hash.l"
thing24144:{
thing24145:fprintf(stderr, "Failed reading value.\n");
thing24146:exit(EXIT_FAILURE);
thing24147:}
thing24148:YY_BREAK
thing24149:case 13:
thing24150:YY_RULE_SETUP
thing24151:#line 74 "hash.l"
thing24152:YY_FATAL_ERROR( "flex scanner jammed" );
thing24153:YY_BREAK
thing24154:#line 867 "hash.c"
thing24155:case YY_STATE_EOF(INITIAL):
thing24156:case YY_STATE_EOF(Key):
thing24157:case YY_STATE_EOF(Value):
thing24158:case YY_STATE_EOF(Comment):
thing24159:case YY_STATE_EOF(CommentOneLine):
thing24160:yyterminate();
thing24161:
thing24162:case YY_END_OF_BUFFER:
thing24163:{
thing24164:/* Amount of text matched not including the EOB char. */
thing24165:int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
thing24166:
thing24167:/* Undo the effects of YY_DO_BEFORE_ACTION. */
thing24168:*yy_cp = (yy_hold_char);
thing24169:YY_RESTORE_YY_MORE_OFFSET
thing24170:
thing24171:if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
thing24172:{
thing24173:/* We're scanning a new file or input source.  It's
thing24174: possible that this happened because the user
thing24175: just pointed yyin at a new source and called
thing24176: yylex().  If so, then we have to assure
thing24177: consistency between YY_CURRENT_BUFFER and our
thing24178: globals.  Here is the right place to do so, because
thing24179: this is the first action (other than possibly a
thing24180: back-up) that will match for the new input source.
thing24181:/
thing24182:(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
thing24183:YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
thing24184:YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
thing24185:}
thing24186:
thing24187:/* Note that here we test for yy_c_buf_p "<=" to the position
thing24188: of the first EOB in the buffer, since yy_c_buf_p will
thing24189: already have been incremented past the NUL character
thing24190: (since all states make transitions on EOB to the
thing24191: end-of-buffer state).  Contrast this with the test
thing24192: in input().
thing24193:/
thing24194:if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
thing24195:{ /* This was really a NUL. */
thing24196:yy_state_type yy_next_state;
thing24197:
thing24198:(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
thing24199:
thing24200:yy_current_state = yy_get_previous_state(  );
thing24201:
thing24202:/* Okay, we're now positioned to make the NUL
thing24203: transition.  We couldn't have
thing24204: yy_get_previous_state() go ahead and do it
thing24205: for us because it doesn't know how to deal
thing24206: with the possibility of jamming (and we don't
thing24207: want to build jamming into it because then it
thing24208: will run more slowly).
thing24209:/
thing24210:
thing24211:yy_next_state = yy_try_NUL_trans( yy_current_state );
thing24212:
thing24213:yy_bp = (yytext_ptr) + YY_MORE_ADJ;
thing24214:
thing24215:if ( yy_next_state )
thing24216:{
thing24217:/* Consume the NUL. */
thing24218:yy_cp = ++(yy_c_buf_p);
thing24219:yy_current_state = yy_next_state;
thing24220:goto yy_match;
thing24221:}
thing24222:
thing24223:else
thing24224:{
thing24225:yy_cp = (yy_c_buf_p);
thing24226:goto yy_find_action;
thing24227:}
thing24228:}
thing24229:
thing24230:else switch ( yy_get_next_buffer(  ) )
thing24231:{
thing24232:case EOB_ACT_END_OF_FILE:
thing24233:{
thing24234:(yy_did_buffer_switch_on_eof) = 0;
thing24235:
thing24236:if ( yywrap(  ) )
thing24237:{
thing24238:/* Note: because we've taken care in
thing24239: yy_get_next_buffer() to have set up
thing24240: yytext, we can now set up
thing24241: yy_c_buf_p so that if some total
thing24242: hoser (like flex itself) wants to
thing24243: call the scanner after we return the
thing24244: YY_NULL, it'll still work - another
thing24245: YY_NULL will get returned.
thing24246:/
thing24247:(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
thing24248:
thing24249:yy_act = YY_STATE_EOF(YY_START);
thing24250:goto do_action;
thing24251:}
thing24252:
thing24253:else
thing24254:{
thing24255:if ( ! (yy_did_buffer_switch_on_eof) )
thing24256:YY_NEW_FILE;
thing24257:}
thing24258:break;
thing24259:}
thing24260:
thing24261:case EOB_ACT_CONTINUE_SCAN:
thing24262:(yy_c_buf_p) =
thing24263:(yytext_ptr) + yy_amount_of_matched_text;
thing24264:
thing24265:yy_current_state = yy_get_previous_state(  );
thing24266:
thing24267:yy_cp = (yy_c_buf_p);
thing24268:yy_bp = (yytext_ptr) + YY_MORE_ADJ;
thing24269:goto yy_match;
thing24270:
thing24271:case EOB_ACT_LAST_MATCH:
thing24272:(yy_c_buf_p) =
thing24273:&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
thing24274:
thing24275:yy_current_state = yy_get_previous_state(  );
thing24276:
thing24277:yy_cp = (yy_c_buf_p);
thing24278:yy_bp = (yytext_ptr) + YY_MORE_ADJ;
thing24279:goto yy_find_action;
thing24280:}
thing24281:break;
thing24282:}
thing24283:
thing24284:default:
thing24285:YY_FATAL_ERROR(
thing24286:"fatal flex scanner internal error--no action found" );
thing24287:} /* end of action switch */
thing24288:} /* end of scanning one token */
thing24289:} /* end of user's declarations */
thing24290:} /* end of yylex */
thing24291:
thing24292:/* yy_get_next_buffer - try to read in a new buffer
thing24293:
thing24294: Returns a code representing an action:
thing24295:	EOB_ACT_LAST_MATCH -
thing24296:	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
thing24297:	EOB_ACT_END_OF_FILE - end of file
thing24298:/
thing24299:static int yy_get_next_buffer (void)
thing24300:{
thing24301:char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
thing24302:char *source = (yytext_ptr);
thing24303:int number_to_move, i;
thing24304:int ret_val;
thing24305:
thing24306:if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
thing24307:YY_FATAL_ERROR(
thing24308:"fatal flex scanner internal error--end of buffer missed" );
thing24309:
thing24310:if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
thing24311:{ /* Don't try to fill the buffer, so this is an EOF. */
thing24312:if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
thing24313:{
thing24314:/* We matched a single character, the EOB, so
thing24315: treat this as a final EOF.
thing24316:/
thing24317:return EOB_ACT_END_OF_FILE;
thing24318:}
thing24319:
thing24320:else
thing24321:{
thing24322:/* We matched some text prior to the EOB, first
thing24323: process it.
thing24324:/
thing24325:return EOB_ACT_LAST_MATCH;
thing24326:}
thing24327:}
thing24328:
thing24329:/* Try to read more data. */
thing24330:
thing24331:/* First move last chars to start of buffer. */
thing24332:number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
thing24333:
thing24334:for ( i = 0; i < number_to_move; ++i )
thing24335:*(dest++) = *(source++);
thing24336:
thing24337:if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
thing24338:/* don't do the read, it's not guaranteed to return an EOF,
thing24339: just force an EOF
thing24340:/
thing24341:YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
thing24342:
thing24343:else
thing24344:{
thing24345:int num_to_read =
thing24346:YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
thing24347:
thing24348:while ( num_to_read <= 0 )
thing24349:{ /* Not enough room in the buffer - grow it. */
thing24350:
thing24351:/* just a shorter name for the current buffer */
thing24352:YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
thing24353:
thing24354:int yy_c_buf_p_offset =
thing24355:(int) ((yy_c_buf_p) - b->yy_ch_buf);
thing24356:
thing24357:if ( b->yy_is_our_buffer )
thing24358:{
thing24359:int new_size = b->yy_buf_size * 2;
thing24360:
thing24361:if ( new_size <= 0 )
thing24362:b->yy_buf_size += b->yy_buf_size / 8;
thing24363:else
thing24364:b->yy_buf_size *= 2;
thing24365:
thing24366:b->yy_ch_buf = (char *)
thing24367:/* Include room in for 2 EOB chars. */
thing24368:yyrealloc( (void *) b->yy_ch_buf,
thing24369:yy_size_t) (b->yy_buf_size + 2)  );
thing24370:}
thing24371:else
thing24372:/* Can't grow it, we don't own it. */
thing24373:b->yy_ch_buf = NULL;
thing24374:
thing24375:if ( ! b->yy_ch_buf )
thing24376:YY_FATAL_ERROR(
thing24377:"fatal error - scanner input buffer overflow" );
thing24378:
thing24379:(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
thing24380:
thing24381:num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
thing24382:number_to_move - 1;
thing24383:
thing24384:}
thing24385:
thing24386:if ( num_to_read > YY_READ_BUF_SIZE )
thing24387:num_to_read = YY_READ_BUF_SIZE;
thing24388:
thing24389:/* Read in more data. */
thing24390:YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
thing24391:(yy_n_chars), num_to_read );
thing24392:
thing24393:YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
thing24394:}
thing24395:
thing24396:if ( (yy_n_chars) == 0 )
thing24397:{
thing24398:if ( number_to_move == YY_MORE_ADJ )
thing24399:{
thing24400:ret_val = EOB_ACT_END_OF_FILE;
thing24401:yyrestart( yyin  );
thing24402:}
thing24403:
thing24404:else
thing24405:{
thing24406:ret_val = EOB_ACT_LAST_MATCH;
thing24407:YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
thing24408:YY_BUFFER_EOF_PENDING;
thing24409:}
thing24410:}
thing24411:
thing24412:else
thing24413:ret_val = EOB_ACT_CONTINUE_SCAN;
thing24414:
thing24415:if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
thing24416:/* Extend the array by 50%, plus the number we really need. */
thing24417:int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
thing24418:YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
thing24419:(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
thing24420:if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
thing24421:YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
thing24422:/* "- 2" to take care of EOB's */
thing24423:YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
thing24424:}
thing24425:
thing24426:(yy_n_chars) += number_to_move;
thing24427:YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
thing24428:YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
thing24429:
thing24430:(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
thing24431:
thing24432:return ret_val;
thing24433:}
thing24434:
thing24435:/* yy_get_previous_state - get the state just before the EOB char was reached */
thing24436:
thing24437:static yy_state_type yy_get_previous_state (void)
thing24438:{
thing24439:yy_state_type yy_current_state;
thing24440:char *yy_cp;
thing24441:
thing24442:yy_current_state = (yy_start);
thing24443:
thing24444:for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
thing24445:{
thing24446:YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
thing24447:if ( yy_accept[yy_current_state] )
thing24448:{
thing24449:(yy_last_accepting_state) = yy_current_state;
thing24450:(yy_last_accepting_cpos) = yy_cp;
thing24451:}
thing24452:while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
thing24453:{
thing24454:yy_current_state = (int) yy_def[yy_current_state];
thing24455:if ( yy_current_state >= 35 )
thing24456:yy_c = yy_meta[yy_c];
thing24457:}
thing24458:yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
thing24459:}
thing24460:
thing24461:return yy_current_state;
thing24462:}
thing24463:
thing24464:/* yy_try_NUL_trans - try to make a transition on the NUL character
thing24465:
thing24466: synopsis
thing24467:	next_state = yy_try_NUL_trans( current_state );
thing24468:/
thing24469:static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
thing24470:{
thing24471:int yy_is_jam;
thing24472:char *yy_cp = (yy_c_buf_p);
thing24473:
thing24474:YY_CHAR yy_c = 1;
thing24475:if ( yy_accept[yy_current_state] )
thing24476:{
thing24477:(yy_last_accepting_state) = yy_current_state;
thing24478:(yy_last_accepting_cpos) = yy_cp;
thing24479:}
thing24480:while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
thing24481:{
thing24482:yy_current_state = (int) yy_def[yy_current_state];
thing24483:if ( yy_current_state >= 35 )
thing24484:yy_c = yy_meta[yy_c];
thing24485:}
thing24486:yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
thing24487:yy_is_jam = (yy_current_state == 34);
thing24488:
thing24489:return yy_is_jam ? 0 : yy_current_state;
thing24490:}
thing24491:
thing24492:#ifndef YY_NO_UNPUT
thing24493:
thing24494:static void yyunput (int c, char * yy_bp )
thing24495:{
thing24496:char *yy_cp;
thing24497:
thing24498:yy_cp = (yy_c_buf_p);
thing24499:
thing24500:/* undo effects of setting up yytext */
thing24501:*yy_cp = (yy_hold_char);
thing24502:
thing24503:if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
thing24504:{ /* need to shift things up to make room */
thing24505:/* +2 for EOB chars. */
thing24506:int number_to_move = (yy_n_chars) + 2;
thing24507:char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
thing24508:YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
thing24509:char *source =
thing24510:&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
thing24511:
thing24512:while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
thing24513:*--dest = *--source;
thing24514:
thing24515:yy_cp += (int) (dest - source);
thing24516:yy_bp += (int) (dest - source);
thing24517:YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
thing24518:(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
thing24519:
thing24520:if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
thing24521:YY_FATAL_ERROR( "flex scanner push-back overflow" );
thing24522:}
thing24523:
thing24524:*--yy_cp = (char) c;
thing24525:
thing24526:(yytext_ptr) = yy_bp;
thing24527:(yy_hold_char) = *yy_cp;
thing24528:(yy_c_buf_p) = yy_cp;
thing24529:}
thing24530:
thing24531:#endif
thing24532:
thing24533:#ifndef YY_NO_INPUT
thing24534:#ifdef __cplusplus
thing24535:static int yyinput (void)
thing24536:#else
thing24537:static int input  (void)
thing24538:#endif
thing24539:
thing24540:{
thing24541:int c;
thing24542:
thing24543:*(yy_c_buf_p) = (yy_hold_char);
thing24544:
thing24545:if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
thing24546:{
thing24547:/* yy_c_buf_p now points to the character we want to return.
thing24548: If this occurs *before* the EOB characters, then it's a
thing24549: valid NUL; if not, then we've hit the end of the buffer.
thing24550:/
thing24551:if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
thing24552:/* This was really a NUL. */
thing24553:*(yy_c_buf_p) = '\0';
thing24554:
thing24555:else
thing24556:{ /* need more input */
thing24557:int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
thing24558:++(yy_c_buf_p);
thing24559:
thing24560:switch ( yy_get_next_buffer(  ) )
thing24561:{
thing24562:case EOB_ACT_LAST_MATCH:
thing24563:/* This happens because yy_g_n_b()
thing24564: sees that we've accumulated a
thing24565: token and flags that we need to
thing24566: try matching the token before
thing24567: proceeding.  But for input(),
thing24568: there's no matching to consider.
thing24569: So convert the EOB_ACT_LAST_MATCH
thing24570: to EOB_ACT_END_OF_FILE.
thing24571:/
thing24572:
thing24573:/* Reset buffer status. */
thing24574:yyrestart( yyin );
thing24575:
thing24576:/*FALLTHROUGH*/
thing24577:
thing24578:case EOB_ACT_END_OF_FILE:
thing24579:{
thing24580:if ( yywrap(  ) )
thing24581:return 0;
thing24582:
thing24583:if ( ! (yy_did_buffer_switch_on_eof) )
thing24584:YY_NEW_FILE;
thing24585:#ifdef __cplusplus
thing24586:return yyinput();
thing24587:#else
thing24588:return input();
thing24589:#endif
thing24590:}
thing24591:
thing24592:case EOB_ACT_CONTINUE_SCAN:
thing24593:(yy_c_buf_p) = (yytext_ptr) + offset;
thing24594:break;
thing24595:}
thing24596:}
thing24597:}
thing24598:
thing24599:c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
thing24600:*(yy_c_buf_p) = '\0';	/* preserve yytext */
thing24601:(yy_hold_char) = *++(yy_c_buf_p);
thing24602:
thing24603:return c;
thing24604:}
thing24605:#endif	/* ifndef YY_NO_INPUT */
thing24606:
thing24607:/** Immediately switch to a different input stream.
thing24608: @param input_file A readable stream.
thing24609: 
thing24610: @note This function does not reset the start condition to @c INITIAL .
thing24611:/
thing24612:void yyrestart  (FILE * input_file )
thing24613:{
thing24614:
thing24615:if ( ! YY_CURRENT_BUFFER ){
thing24616:yyensure_buffer_stack ();
thing24617:YY_CURRENT_BUFFER_LVALUE =
thing24618:yy_create_buffer( yyin, YY_BUF_SIZE );
thing24619:}
thing24620:
thing24621:yy_init_buffer( YY_CURRENT_BUFFER, input_file );
thing24622:yy_load_buffer_state(  );
thing24623:}
thing24624:
thing24625:/** Switch to a different input buffer.
thing24626: @param new_buffer The new input buffer.
thing24627: 
thing24628:/
thing24629:void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
thing24630:{
thing24631:
thing24632:/* TODO. We should be able to replace this entire function body
thing24633: with
thing24634:		yypop_buffer_state();
thing24635:		yypush_buffer_state(new_buffer);
thing24636:/
thing24637:yyensure_buffer_stack ();
thing24638:if ( YY_CURRENT_BUFFER == new_buffer )
thing24639:return;
thing24640:
thing24641:if ( YY_CURRENT_BUFFER )
thing24642:{
thing24643:/* Flush out information for old buffer. */
thing24644:*(yy_c_buf_p) = (yy_hold_char);
thing24645:YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
thing24646:YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
thing24647:}
thing24648:
thing24649:YY_CURRENT_BUFFER_LVALUE = new_buffer;
thing24650:yy_load_buffer_state(  );
thing24651:
thing24652:/* We don't actually know whether we did this switch during
thing24653: EOF (yywrap()) processing, but the only time this flag
thing24654: is looked at is after yywrap() is called, so it's safe
thing24655: to go ahead and always set it.
thing24656:/
thing24657:(yy_did_buffer_switch_on_eof) = 1;
thing24658:}
thing24659:
thing24660:static void yy_load_buffer_state  (void)
thing24661:{
thing24662:(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
thing24663:(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
thing24664:yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
thing24665:(yy_hold_char) = *(yy_c_buf_p);
thing24666:}
thing24667:
thing24668:/** Allocate and initialize an input buffer state.
thing24669: @param file A readable stream.
thing24670: @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
thing24671: 
thing24672: @return the allocated buffer state.
thing24673:/
thing24674:YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
thing24675:{
thing24676:YY_BUFFER_STATE b;
thing24677:
thing24678:b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
thing24679:if ( ! b )
thing24680:YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
thing24681:
thing24682:b->yy_buf_size = size;
thing24683:
thing24684:/* yy_ch_buf has to be 2 characters longer than the size given because
thing24685: we need to put in 2 end-of-buffer characters.
thing24686:/
thing24687:b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
thing24688:if ( ! b->yy_ch_buf )
thing24689:YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
thing24690:
thing24691:b->yy_is_our_buffer = 1;
thing24692:
thing24693:yy_init_buffer( b, file );
thing24694:
thing24695:return b;
thing24696:}
thing24697:
thing24698:/** Destroy the buffer.
thing24699: @param b a buffer created with yy_create_buffer()
thing24700: 
thing24701:/
thing24702:void yy_delete_buffer (YY_BUFFER_STATE  b )
thing24703:{
thing24704:
thing24705:if ( ! b )
thing24706:return;
thing24707:
thing24708:if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
thing24709:YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
thing24710:
thing24711:if ( b->yy_is_our_buffer )
thing24712:yyfree( (void *) b->yy_ch_buf  );
thing24713:
thing24714:yyfree( (void *) b  );
thing24715:}
thing24716:
thing24717:/* Initializes or reinitializes a buffer.
thing24718: This function is sometimes called more than once on the same buffer,
thing24719: such as during a yyrestart() or at EOF.
thing24720:/
thing24721:static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
thing24722:
thing24723:{
thing24724:int oerrno = errno;
thing24725:
thing24726:yy_flush_buffer( b );
thing24727:
thing24728:b->yy_input_file = file;
thing24729:b->yy_fill_buffer = 1;
thing24730:
thing24731:/* If b is the current buffer, then yy_init_buffer was _probably_
thing24732: called from yyrestart() or through yy_get_next_buffer.
thing24733: In that case, we don't want to reset the lineno or column.
thing24734:/
thing24735:if (b != YY_CURRENT_BUFFER){
thing24736:b->yy_bs_lineno = 1;
thing24737:b->yy_bs_column = 0;
thing24738:}
thing24739:
thing24740:b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
thing24741:
thing24742:errno = oerrno;
thing24743:}
thing24744:
thing24745:/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
thing24746: @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
thing24747: 
thing24748:/
thing24749:void yy_flush_buffer (YY_BUFFER_STATE  b )
thing24750:{
thing24751:if ( ! b )
thing24752:return;
thing24753:
thing24754:b->yy_n_chars = 0;
thing24755:
thing24756:/* We always need two end-of-buffer characters.  The first causes
thing24757: a transition to the end-of-buffer state.  The second causes
thing24758: a jam in that state.
thing24759:/
thing24760:b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
thing24761:b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
thing24762:
thing24763:b->yy_buf_pos = &b->yy_ch_buf[0];
thing24764:
thing24765:b->yy_at_bol = 1;
thing24766:b->yy_buffer_status = YY_BUFFER_NEW;
thing24767:
thing24768:if ( b == YY_CURRENT_BUFFER )
thing24769:yy_load_buffer_state(  );
thing24770:}
thing24771:
thing24772:/** Pushes the new state onto the stack. The new state becomes
thing24773:  the current state. This function will allocate the stack
thing24774:  if necessary.
thing24775:  @param new_buffer The new state.
thing24776:  
thing24777:/
thing24778:void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
thing24779:{
thing24780:if (new_buffer == NULL)
thing24781:return;
thing24782:
thing24783:yyensure_buffer_stack();
thing24784:
thing24785:/* This block is copied from yy_switch_to_buffer. */
thing24786:if ( YY_CURRENT_BUFFER )
thing24787:{
thing24788:/* Flush out information for old buffer. */
thing24789:*(yy_c_buf_p) = (yy_hold_char);
thing24790:YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
thing24791:YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
thing24792:}
thing24793:
thing24794:/* Only push if top exists. Otherwise, replace top. */
thing24795:if (YY_CURRENT_BUFFER)
thing24796:(yy_buffer_stack_top)++;
thing24797:YY_CURRENT_BUFFER_LVALUE = new_buffer;
thing24798:
thing24799:/* copied from yy_switch_to_buffer. */
thing24800:yy_load_buffer_state(  );
thing24801:(yy_did_buffer_switch_on_eof) = 1;
thing24802:}
thing24803:
thing24804:/** Removes and deletes the top of the stack, if present.
thing24805:  The next element becomes the new top.
thing24806:  
thing24807:/
thing24808:void yypop_buffer_state (void)
thing24809:{
thing24810:if (!YY_CURRENT_BUFFER)
thing24811:return;
thing24812:
thing24813:yy_delete_buffer(YY_CURRENT_BUFFER );
thing24814:YY_CURRENT_BUFFER_LVALUE = NULL;
thing24815:if ((yy_buffer_stack_top) > 0)
thing24816:--(yy_buffer_stack_top);
thing24817:
thing24818:if (YY_CURRENT_BUFFER) {
thing24819:yy_load_buffer_state(  );
thing24820:(yy_did_buffer_switch_on_eof) = 1;
thing24821:}
thing24822:}
thing24823:
thing24824:/* Allocates the stack if it does not exist.
thing24825:  Guarantees space for at least one push.
thing24826:/
thing24827:static void yyensure_buffer_stack (void)
thing24828:{
thing24829:yy_size_t num_to_alloc;
thing24830:
thing24831:if (!(yy_buffer_stack)) {
thing24832:
thing24833:/* First allocation is just for 2 elements, since we don't know if this
thing24834: scanner will even need a stack. We use 2 instead of 1 to avoid an
thing24835: immediate realloc on the next call.
thing24836:/
thing24837:um_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
thing24838:(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
thing24839:(num_to_alloc * sizeof(struct yy_buffer_state*)
thing24840:);
thing24841:if ( ! (yy_buffer_stack) )
thing24842:YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
thing24843:
thing24844:memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
thing24845:
thing24846:(yy_buffer_stack_max) = num_to_alloc;
thing24847:(yy_buffer_stack_top) = 0;
thing24848:return;
thing24849:}
thing24850:
thing24851:if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
thing24852:
thing24853:/* Increase the buffer to prepare for a possible push. */
thing24854:yy_size_t grow_size = 8 /* arbitrary grow size */;
thing24855:
thing24856:num_to_alloc = (yy_buffer_stack_max) + grow_size;
thing24857:(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
thing24858:((yy_buffer_stack),
thing24859:num_to_alloc * sizeof(struct yy_buffer_state*)
thing24860:);
thing24861:if ( ! (yy_buffer_stack) )
thing24862:YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
thing24863:
thing24864:/* zero only the new slots.*/
thing24865:memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
thing24866:(yy_buffer_stack_max) = num_to_alloc;
thing24867:}
thing24868:}
thing24869:
thing24870:/** Setup the input buffer state to scan directly from a user-specified character buffer.
thing24871: @param base the character buffer
thing24872: @param size the size in bytes of the character buffer
thing24873: 
thing24874: @return the newly allocated buffer state object.
thing24875:/
thing24876:YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
thing24877:{
thing24878:YY_BUFFER_STATE b;
thing24879:
thing24880:if ( size < 2 ||
thing24881:ase[size-2] != YY_END_OF_BUFFER_CHAR ||
thing24882:ase[size-1] != YY_END_OF_BUFFER_CHAR )
thing24883:/* They forgot to leave room for the EOB's. */
thing24884:return NULL;
thing24885:
thing24886:b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
thing24887:if ( ! b )
thing24888:YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
thing24889:
thing24890:b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
thing24891:b->yy_buf_pos = b->yy_ch_buf = base;
thing24892:b->yy_is_our_buffer = 0;
thing24893:b->yy_input_file = NULL;
thing24894:b->yy_n_chars = b->yy_buf_size;
thing24895:b->yy_is_interactive = 0;
thing24896:b->yy_at_bol = 1;
thing24897:b->yy_fill_buffer = 0;
thing24898:b->yy_buffer_status = YY_BUFFER_NEW;
thing24899:
thing24900:yy_switch_to_buffer( b  );
thing24901:
thing24902:return b;
thing24903:}
thing24904:
thing24905:/** Setup the input buffer state to scan a string. The next call to yylex() will
thing24906: scan from a @e copy of @a str.
thing24907: @param yystr a NUL-terminated string to scan
thing24908: 
thing24909: @return the newly allocated buffer state object.
thing24910: @note If you want to scan bytes that may contain NUL values, then use
thing24911:       yy_scan_bytes() instead.
thing24912:/
thing24913:YY_BUFFER_STATE yy_scan_string (const char * yystr )
thing24914:{
thing24915:
thing24916:return yy_scan_bytes( yystr, (int) strlen(yystr) );
thing24917:}
thing24918:
thing24919:/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
thing24920: scan from a @e copy of @a bytes.
thing24921: @param yybytes the byte buffer to scan
thing24922: @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
thing24923: 
thing24924: @return the newly allocated buffer state object.
thing24925:/
thing24926:YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
thing24927:{
thing24928:YY_BUFFER_STATE b;
thing24929:char *buf;
thing24930:yy_size_t n;
thing24931:int i;
thing24932:
thing24933:/* Get memory for full buffer, including space for trailing EOB's. */
thing24934:n = (yy_size_t) (_yybytes_len + 2);
thing24935:buf = (char *) yyalloc( n  );
thing24936:if ( ! buf )
thing24937:YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
thing24938:
thing24939:for ( i = 0; i < _yybytes_len; ++i )
thing24940:buf[i] = yybytes[i];
thing24941:
thing24942:buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
thing24943:
thing24944:b = yy_scan_buffer( buf, n );
thing24945:if ( ! b )
thing24946:YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
thing24947:
thing24948:/* It's okay to grow etc. this buffer, and we should throw it
thing24949: away when we're done.
thing24950:/
thing24951:b->yy_is_our_buffer = 1;
thing24952:
thing24953:return b;
thing24954:}
thing24955:
thing24956:#ifndef YY_EXIT_FAILURE
thing24957:#define YY_EXIT_FAILURE 2
thing24958:#endif
thing24959:
thing24960:static void yynoreturn yy_fatal_error (const char* msg )
thing24961:{
thing24962:fprintf( stderr, "%s\n", msg );
thing24963:exit( YY_EXIT_FAILURE );
thing24964:}
thing24965:
thing24966:/* Redefine yyless() so it works in section 3 code. */
thing24967:
thing24968:#undef yyless
thing24969:#define yyless(n) \
thing24970:do \
thing24971:{ \
thing24972:/* Undo effects of setting up yytext. */ \
thing24973:int yyless_macro_arg = (n); \
thing24974:YY_LESS_LINENO(yyless_macro_arg);\
thing24975:yytext[yyleng] = (yy_hold_char); \
thing24976:(yy_c_buf_p) = yytext + yyless_macro_arg; \
thing24977:(yy_hold_char) = *(yy_c_buf_p); \
thing24978:*(yy_c_buf_p) = '\0'; \
thing24979:yyleng = yyless_macro_arg; \
thing24980:} \
thing24981:while ( 0 )
thing24982:
thing24983:/* Accessor  methods (get/set functions) to struct members. */
thing24984:
thing24985:/** Get the current line number.
thing24986: 
thing24987:/
thing24988:int yyget_lineno  (void)
thing24989:{
thing24990:
thing24991:return yylineno;
thing24992:}
thing24993:
thing24994:/** Get the input stream.
thing24995: 
thing24996:/
thing24997:FILE *yyget_in  (void)
thing24998:{
thing24999:return yyin;
thing25000:}
thing25001:
thing25002:/** Get the output stream.
thing25003: 
thing25004:/
thing25005:FILE *yyget_out  (void)
thing25006:{
thing25007:return yyout;
thing25008:}
thing25009:
thing25010:/** Get the length of the current token.
thing25011: 
thing25012:/
thing25013:int yyget_leng  (void)
thing25014:{
thing25015:return yyleng;
thing25016:}
thing25017:
thing25018:/** Get the current token.
thing25019: 
thing25020:/
thing25021:
thing25022:char *yyget_text  (void)
thing25023:{
thing25024:return yytext;
thing25025:}
thing25026:
thing25027:/** Set the current line number.
thing25028: @param _line_number line number
thing25029: 
thing25030:/
thing25031:void yyset_lineno (int  _line_number )
thing25032:{
thing25033:
thing25034:yylineno = _line_number;
thing25035:}
thing25036:
thing25037:/** Set the input stream. This does not discard the current
thing25038: input buffer.
thing25039: @param _in_str A readable stream.
thing25040: 
thing25041: @see yy_switch_to_buffer
thing25042:/
thing25043:void yyset_in (FILE *  _in_str )
thing25044:{
thing25045:yyin = _in_str ;
thing25046:}
thing25047:
thing25048:void yyset_out (FILE *  _out_str )
thing25049:{
thing25050:yyout = _out_str ;
thing25051:}
thing25052:
thing25053:int yyget_debug  (void)
thing25054:{
thing25055:return yy_flex_debug;
thing25056:}
thing25057:
thing25058:void yyset_debug (int  _bdebug )
thing25059:{
thing25060:yy_flex_debug = _bdebug ;
thing25061:}
thing25062:
thing25063:static int yy_init_globals (void)
thing25064:{
thing25065:/* Initialization is the same as for the non-reentrant scanner.
thing25066: This function is called from yylex_destroy(), so don't allocate here.
thing25067:/
thing25068:
thing25069:(yy_buffer_stack) = NULL;
thing25070:(yy_buffer_stack_top) = 0;
thing25071:(yy_buffer_stack_max) = 0;
thing25072:(yy_c_buf_p) = NULL;
thing25073:(yy_init) = 0;
thing25074:(yy_start) = 0;
thing25075:
thing25076:/* Defined in main.c */
thing25077:#ifdef YY_STDINIT
thing25078:yyin = stdin;
thing25079:yyout = stdout;
thing25080:#else
thing25081:yyin = NULL;
thing25082:yyout = NULL;
thing25083:#endif
thing25084:
thing25085:/* For future reference: Set errno on error, since we are called by
thing25086: yylex_init()
thing25087:/
thing25088:return 0;
thing25089:}
thing25090:
thing25091:/* yylex_destroy is for both reentrant and non-reentrant scanners. */
thing25092:int yylex_destroy  (void)
thing25093:{
thing25094:
thing25095:/* Pop the buffer stack, destroying each element. */
thing25096:while(YY_CURRENT_BUFFER){
thing25097:yy_delete_buffer( YY_CURRENT_BUFFER  );
thing25098:YY_CURRENT_BUFFER_LVALUE = NULL;
thing25099:yypop_buffer_state();
thing25100:}
thing25101:
thing25102:/* Destroy the stack itself. */
thing25103:yyfree((yy_buffer_stack) );
thing25104:(yy_buffer_stack) = NULL;
thing25105:
thing25106:/* Reset the globals. This is important in a non-reentrant scanner so the next time
thing25107: yylex() is called, initialization will occur. */
thing25108:yy_init_globals( );
thing25109:
thing25110:return 0;
thing25111:}
thing25112:
thing25113:/*
thing25114: Internal utility routines.
thing25115:/
thing25116:
thing25117:#ifndef yytext_ptr
thing25118:static void yy_flex_strncpy (char* s1, const char * s2, int n )
thing25119:{
thing25120:
thing25121:int i;
thing25122:for ( i = 0; i < n; ++i )
thing25123:s1[i] = s2[i];
thing25124:}
thing25125:#endif
thing25126:
thing25127:#ifdef YY_NEED_STRLEN
thing25128:static int yy_flex_strlen (const char * s )
thing25129:{
thing25130:int n;
thing25131:for ( n = 0; s[n]; ++n )
thing25132:;
thing25133:
thing25134:return n;
thing25135:}
thing25136:#endif
thing25137:
thing25138:void *yyalloc (yy_size_t  size )
thing25139:{
thing25140:return malloc(size);
thing25141:}
thing25142:
thing25143:void *yyrealloc  (void * ptr, yy_size_t  size )
thing25144:{
thing25145:
thing25146:/* The cast to (char *) in the following accommodates both
thing25147: implementations that use char* generic pointers, and those
thing25148: that use void* generic pointers.  It works with the latter
thing25149: because both ANSI C and C++ allow castless assignment from
thing25150: any pointer type to void*, and deal with argument conversions
thing25151: as though doing an assignment.
thing25152:/
thing25153:return realloc(ptr, size);
thing25154:}
thing25155:
thing25156:void yyfree (void * ptr )
thing25157:{
thing25158:free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
thing25159:}
thing25160:
thing25161:#define YYTABLES_NAME "yytables"
thing25162:
thing25163:#line 74 "hash.l"
thing25164:
thing25165:#include <stdio.h>
thing25166:
thing25167:static uint32_t make_hash(char *key)
thing25168:{
thing25169:char *c = key;
thing25170:uint32_t hash = 0, i = 0;
thing25171:/* while (*c++ != '\0' && ++i) hash += (i * *c) % (2 * *c + 256 * i); */
thing25172:/* while (*c++ != '\0' && ++i) hash += (i * i * i * i * *c) % (2 * *c + 256 * i); */
thing25173:int p = 119569;
thing25174:while (*c++ != '\0' && ++i) { int a=1; for (int j=0;j<i-1;j++){a*=123;}hash+=a* *c + i*i*i*i;}
thing25175:return hash%p;
thing25176:}
thing25177:
thing25178:static void dictionary_add(Dictionary *dictionary, char *key, char *value)
thing25179:{
thing25180:uint32_t hash = make_hash(key) % dictionary->size;
thing25181:
thing25182:void *cur = dictionary->table[hash];
thing25183:void *last = cur;
thing25184:while (cur != NULL) {
thing25185:last = cur;
thing25186:cur = ((DictNode *) cur)->next;
thing25187:}
thing25188:void *new = calloc(1, sizeof(void *) + (strlen(value) + 1) * sizeof(char));
thing25189:if (new == NULL) {
thing25190:fprintf(stderr, "ERROR: Could not allocate memory for new entry in dictionary.\n");
thing25191:exit(EXIT_FAILURE);
thing25192:}
thing25193:((DictNode *) new)->next = NULL;
thing25194:strcpy(&(((DictNode *) new)->value), value);
thing25195:if (last == NULL) {
thing25196:dictionary->table[hash] = new;
thing25197:} else {
thing25198:((DictNode *) last)->next = new;
thing25199:}
thing25200:}
thing25201:
thing25202:static void ___free_end_dict_list(void *cur)
thing25203:{
thing25204:if (((DictNode *) cur)->next != NULL) ___free_end_dict_list(((DictNode *) cur)->next);
thing25205:free(cur);
thing25206:}
thing25207:static void destroy_dictionary(Dictionary *dictionary)
thing25208:{
thing25209:if (dictionary != NULL) {
thing25210:if (dictionary->table != NULL) {
thing25211:for (int i = 0; i < dictionary->size; i++) {
thing25212:if (dictionary->table[i] != NULL) {
thing25213:___free_end_dict_list(dictionary->table[i]);
thing25214:}
thing25215:}
thing25216:free(dictionary->table);
thing25217:}
thing25218:free(dictionary);
thing25219:}
thing25220:}
thing25221:static Dictionary *new_dictionary(uint32_t size)
thing25222:{
thing25223:Dictionary *dic = (Dictionary *) calloc(1, sizeof(Dictionary));
thing25224:if (dic == NULL) goto mem_error;
thing25225:dic->size = size;
thing25226:dic->table = (void **) calloc(size, sizeof(void *));
thing25227:if (dic->table == NULL) goto mem_error;
thing25228:return dic;
thing25229:mem_error:
thing25230:fprintf(stderr, "ERROR: Failed to allocate memory for dictionary.\n");
thing25231:exit(EXIT_FAILURE);
thing25232:}
thing25233:
thing25234:static void print_dictionary(Dictionary *dictionary)
thing25235:{
thing25236:printf("DICTIONARY\n");
thing25237:printf("SIZE: %u\n", dictionary->size);
thing25238:for (int i = 0; i < dictionary->size; i++) {
thing25239:printf("[");
thing25240:void *c = dictionary->table[i];
thing25241:int num = 0;
thing25242:while(c!=NULL&&++num){printf("%s%s",num==1?"":", ",((char*)(c+sizeof(void*))));c=*((void**)c);}
thing25243:printf("]\n");
thing25244:}
thing25245:}
thing25246:
thing25247:int main(int argc, char **argv)
thing25248:{
thing25249:if (argc != 2) {
thing25250:fprintf(stderr, "give good args\n");
thing25251:exit(EXIT_FAILURE);
thing25252:}
thing25253:
thing25254:FILE *file = fopen(argv[1], "r");
thing25255:if (file == NULL) {
thing25256:fprintf(stderr, "file failed to open\n");
thing25257:exit(EXIT_FAILURE);
thing25258:}
thing25259:yyin = file;
thing25260:
thing25261:destroy_dictionary(g_dictionary);
thing25262:g_dictionary = new_dictionary(64);
thing25263:
thing25264:BEGIN Key;
thing25265:yylex();
thing25266:
thing25267:print_dictionary(g_dictionary);
thing25268:}
thing25269:

