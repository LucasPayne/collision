/*--------------------------------------------------------------------------------
   Rendering module.
Dependencies:
	resources:  Basic graphics objects are formed as resources, special kinds of shared objects tied to assets.
	dictionary: A basic key-value-pair file format used here for configuring graphics objects.
--------------------------------------------------------------------------------*/
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "helper_definitions.h"
#include "resources.h"
#include "rendering.h"
#include "dictionary.h"
#include "ply.h" // should remove this dependency?


// Rendering resources
//================================================================================
ResourceType Shader_RTID;
static void *Shader_load(char *path)
{
    // Path format:
    //      Drive/path/to/shader.{vert,geom,frag}
    // Corresponds directly to a GLSL shader source file.
    ShaderType shader_type;
    char *suffix;
    // Want to keep the shader asset as a simple file, so infer the shader type from the path. 
    if ((suffix = strrchr(path, '.')) == NULL) return NULL;
    if (strcmp(suffix + 1, "vert") == 0) {
        shader_type = Vertex;
    } else if (strcmp(suffix + 1, "frag") == 0) {
        shader_type = Fragment;
    } else if (strcmp(suffix + 1, "geom") == 0) {
        shader_type = Geometry;
    } else {
        return NULL;
    }
    GLenum gl_shader_type = gl_shader_type(shader_type);
    if (gl_shader_type == 0) return NULL;
    GraphicsID shader_id = glCreateShader(gl_shader_type);
    printf("created id: %d\n", shader_id);
    // Load the shader source from the physical path, and attempt to compile it.
    char shader_path_buffer[1024];
    if (!resource_file_path(path, "", shader_path_buffer, 1024)) {
        fprintf(stderr, "FAILED TO GET SHADER FILE PATH\n");
        exit(EXIT_FAILURE);
        return NULL;
    }
    printf("Shader path: \"%s\"\n", shader_path_buffer);
    if (!load_and_compile_shader(shader_id, shader_path_buffer)) {
        fprintf(stderr, "FAILED TO COMPILE SHADER\n");
        exit(EXIT_FAILURE);
        return NULL;
    }
    // The shader has been compiled and associated to the created shader ID.
    // Create the Shader resource and return it.
    Shader *shader = (Shader *) calloc(1, sizeof(Shader));
    mem_check(shader);
    shader->shader_type = shader_type;
    printf("Setting shader_id: %u\n", shader_id);
    shader->shader_id = shader_id;
    return (void *) shader;
}
ResourceType GraphicsProgram_RTID;
static void *GraphicsProgram_load(char *path)
{
    //----------------Fatal error messages are here for now for testing.
    // Path format:
    //      Drive/path/to/graphicsprogram
    // Associated build files:
    //      .../path/to/graphicsprogram.GraphicsProgram
    // This is a standard key-value pairs file with graphics program information.
    FILE *file = resource_file_open(path, ".GraphicsProgram", "r");
    if (file == NULL) {
        fprintf(stderr, "COULD NOT OPEN GRAPHICS PROGRAM FILE\n");
        return NULL;
    }
    Dictionary *dict = dictionary_read(file);
    if (dict == NULL) {
        fprintf(stderr, "COULD NOT READ DICTIONARY FOR GRAPHICS PROGRAM\n");
        return NULL;
    }
    
    // Read in entries from the dictionary.
    const int buf_size = 512;
    char buf[buf_size];

    VertexFormat vertex_format;
    char vertex_shader_path[buf_size];
    char fragment_shader_path[buf_size];

    if (!dict_get(dict, "vertex_format", buf, buf_size)) {
        fprintf(stderr, "COULD NOT FIND vertex_format\n");
        return NULL;
    }
    printf("vertex_format: %s\n", buf);
    if (strcmp(buf, "3C") == 0) {
        vertex_format = VERTEX_FORMAT_3C;
    } else {
        //----account for vertex formats
        fprintf(stderr, "INVALID VERTEX FORMAT\n");
        return NULL;
    }
    if (!dict_get(dict, "vertex_shader", buf, buf_size)) {
        fprintf(stderr, "COULD NOT FIND vertex_shader\n");
        return NULL;
    }
    strncpy(vertex_shader_path, buf, buf_size);
    if (!dict_get(dict, "fragment_shader", buf, buf_size)) {
        fprintf(stderr, "COULD NOT FIND fragment_shader\n");
        return NULL;
    }
    strncpy(fragment_shader_path, buf, buf_size);

/* typedef struct /1* Resource *1/ GraphicsProgram_s { */
/*     GraphicsID program_id; */
/*     GraphicsProgramType program_type; */
/*     ResourceHandle shaders[NUM_SHADER_TYPES]; /1* Resources: Shader[] *1/ */
/*     VertexFormat vertex_format; */
/*     uint16_t num_uniforms; */
/*     Uniform *uniform_array; */
/* } GraphicsProgram; */

    GraphicsProgram *program = (GraphicsProgram *) calloc(1, sizeof(GraphicsProgram));
    mem_check(program);
    program->program_id = glCreateProgram();
    if (program->program_id == 0) return NULL;
    program->program_type = GRAPHICS_PROGRAM_VF; // Only using vertex and fragment shaders.
    program->vertex_format = vertex_format;
      // how to deal with uniforms?
      program->num_uniforms = 0;
      program->uniform_array = NULL;

    // If create new resource handles !!! REMEMBER TO FREE if resource load fails. So, adding them last.
    program->shaders[Vertex] = new_resource_handle(Shader, vertex_shader_path);
    program->shaders[Fragment] = new_resource_handle(Shader, fragment_shader_path);

    // Resources for shaders have been associated. Now, attach them and link them to this GraphicsProgram object.
    glAttachShader(program->program_id, resource_data(Shader, program->shaders[Vertex])->shader_id);
    glAttachShader(program->program_id, resource_data(Shader, program->shaders[Fragment])->shader_id);
    link_shader_program(program->program_id);

    destroy_dictionary(dict);
    return (void *) program;
}
ResourceType Mesh_RTID;
static void *Mesh_load(char *path)
{
    return NULL;
}

void init_resources_rendering(void)
{
    add_resource_type(Shader);
    add_resource_type(GraphicsProgram);
    add_resource_type(Mesh);
}
