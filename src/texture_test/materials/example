// example shader block "header" file

StandardGlobal.shaderblock
--------------------------
struct SomeStruct {
    float stuff;
    vec3 thing;
};
float time;
float aspect_ratio;
int screen_width;
int screen_height;
SomeStruct structs[10];


-----------------------
GLSL header
-----------------------
struct SomeStruct {
    float stuff;
    vec3 thing;
};
layout (std140) uniform StandardGlobal {
    float time;
    float aspect_ratio;
    int screen_width;
    int screen_height;
    SomeStruct structs[10];
};

-----------------------
C header
-----------------------

struct ShaderBlock_StandardGlobal_SomeStruct {
    float stuff;
    vec3 thing;
};
struct ShaderBlockFlags_StandardGlobal_SomeStruct {
    bool stuff;
    bool thing;
};
struct ShaderBlockstd140Map_StandardGlobal_SomeStruct {
    uint16_t stuff;
    uint16_t thing;
};

struct ShaderBlock_StandardGlobal {
    float time;
    float aspect_ratio;
    int screen_width;
    int screen_height;
    struct ShaderBlock_StandardGlobal_SomeStruct structs[10];
};
struct ShaderBlockFlags_StandardGlobal {
    bool time;
    bool aspect_ratio;
    bool screen_width;
    bool screen_height;
// idea probably breaks down here.
// would a bool be kept for this struct?
    struct ShaderBlockFlags_StandardGlobal_SomeStruct structs[10];
};
struct ShaderBlockstd140Map_StandardGlobal {
    uint16_t time;
    uint16_t aspect_ratio;
    uint16_t screen_width;
    uint16_t screen_height;
// and same here.
    uint16_t ShaderBlock_StandardGlobalstd140Map_SomeStruct structs[10];
};
================================================================================
Or, since generation is used anyway, have it generate a padded struct. The only important thing
is to keep the same names for the macro usage.

uniform_set_mat4x4(SomeStuff, things[j].stuff.matrices[i], &mat.vals);

___uniform_set_mat4x4(( ShaderBlockID_Standard3D ),
                    &(( g_shaderblocks[( ShaderBlockID_Standard3D )].things[j].stuff.matrices[i] )),
                    &mat.vals);

struct ShaderBlock_SomeStuff_Stuff {
    mat3x3 matrices; // padded?
};
struct ShaderBlock_SomeStuff_Thing {
    ShaderBlock_SomeStuff_Stuff stuff;
    vec3 a;
    PAD ___pad1;
    float y;
};
struct ShaderBlock_SomeStuff {
    vec3 v;
    PAD ___pad1;
    vec4 a;
    vec3 b;
    PAD ___pad2;
    float thing;
    float other_thing;
    vec4 color;
    PADDED_vec4 vectors[10];
    struct ShaderBlock_SomeStuff_Thing things[20];
};
Also, technical details about structure padding, matrices, vectors, etc. With that, generate
a struct which will be mapped directly into the vram buffer (at least parts of it).

Bitflags and structures and arrays
How? What is wanted is a mapping from the potentially complicated macro symbol for the entry, e.g.,
things.stuff[10].x.y[2].z, to a dirty-flag. So thing.stuff has a flag, but also thing.stuff.x or thing.things and thing.things[10], etc.

Is this even worth it? It does seem like a nice syntax for updating uniforms without string manipulation. The application has used shared-shader-blocks
anyway, which it wants to control, so it seems fine to hardcode it in a numbers/address based way, with macros to expand from symbols to those numbers.
Also the shader block type initialization, like the resource type initialization, seems neccessary. Macros expand from the symbol to the global type ID variable,
and pass that to the underlying functions. This global ID variable is set on type-initialization. So there is no expected type ID for a type, they are built
up at runtime, and this makes it natural to have libraries/modules define shader-block types (and resource types, etc.).

