#version 420
#block Standard3D

layout (quads, equal_spacing, ccw) in;

uniform float line_width;
// uniform float antialiasing_radius;
// const float antialiasing_radius = 0.01;

out vec2 uv;

in controlled_vertex {
    vec3 ndc_position;
} vertex_outputs[];

void main(void)
{
    vec2 A = vertex_outputs[0].ndc_position.xy;
    vec2 B = vertex_outputs[1].ndc_position.xy;

    vec2 mid_point = (A + B) / 2;
    vec2 X_axis = B - A;
    float line_length = length(X_axis);
    float inv_line_length = 1.0 / line_length; //---- need to handle degenerate line segments.
    X_axis *= inv_line_length;
    vec2 Y_axis = vec2(-X_axis.y, X_axis.x);

    float u = 2*gl_TessCoord[0] - 1;
    float v = 2*gl_TessCoord[1] - 1;
    uv = vec2(u, v);
    //gl_Position = vec4(0.8*u, 0.8*v, 0.5, 1);
    //gl_Position = vec4(A.x + (B.x - A.x)*gl_TessCoord[0], A.y + (B.y - A.y)*gl_TessCoord[1], 0.5, 1);
    // gl_Position = vec4(mid_point + u * X_axis * 0.03 + v * Y_axis * 0.03, 0.5, 1);
    
    float lw = 0.03;
    float half_extended_line_length = 0.5 * (line_length + lw);
    float half_extended_line_height = 0.5 * lw;
    gl_Position = vec4(mid_point + u*X_axis*half_extended_line_length + v*Y_axis*half_extended_line_height, vertex_outputs[0].ndc_position.z, 1); //--- need to interpolate depths so weird clipping doesn't happen.
}
/*

layout (quads, equal_spacing, ccw) in;

#define TWOPI ( radians(360) )

// The single tPosition is the center of the sphere.
in controlled_vertex {
    vec3 tPosition;
} vertex_inputs[];

uniform float line_width;

void main(void)
{
    float radius = line_width;

    float x,y;
    x = gl_TessCoord[0];
    y = gl_TessCoord[1];

    float a = 2*y-1;
    float b = sqrt(1 - a*a);
    vec3 pos = vertex_inputs[0].tPosition + radius*vec3(b*cos(TWOPI*x), a, b*sin(TWOPI*x));
    
    gl_Position = mvp_matrix * vec4(pos, 1);
}
*/
